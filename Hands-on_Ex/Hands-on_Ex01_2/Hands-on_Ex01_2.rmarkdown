---
title: "Hands-on Exercise 01-2"
author: "Yiqiong PAN"
date: "Aug 28, 2025"
date-modified: "last-modified"
---





## **Ex2 Thematic Mapping and GeoVisualisation with R**

**Thematic mapping:** using map symbols to visualise geographic features.

**Geovisualisation**: the combination of cartography, computer science, and visualisation to enhance spatial understanding and support knowledge discovery.

### 2.2 Getting started:

Packages used:

**tmap:** for plotting choropleth maps

**readr:** for importing CSV files (tidyverse)

**tidyr:** for tidying data (tidyverse)

**dplyr:** for wrangling data (tidyverse)

**sf:** for processing geospatial vector data

**rvest:** for scraping data from web pages

Here we load the required packages into R environment.if they are not installed, we could install them first via function **install.packages()** and then load them into R by using p_load().





```{r}
pacman::p_load(sf,tmap,tidyverse,rvest)
```





### 2.3 Importing Data into R.

Geospatial data is Master Plan 2019 Subzone Boundary (No Sea) (KML) downloaded from data.gov.sg.

Aspatial data is Singapore Residents by Planning Area / Subzone, Age Group, Sex and Type of Dwelling, June 2024 in csv format from DOS.

#### 2.3.2 importing Geo spatial Data into R

The code chunk below use **st_read()** function from sf package to import Geospatial data: Master Plan 2019 Subzone Boundary (No Sea) (KML).





```{r}
mpsz <- st_read("data/geospatial/MasterPlan2019SubzoneBoundaryNoSeaKML.kml")
```





**2.3.2.1 Tidying Data**





```{r}
#quick overview of the subzone data
st_geometry(mpsz)
glimpse(mpsz)
mpsz$Description[1:10] 
#first 10: each has a small table of key–value rows like SUBZONE_N:DEPOT ROAD, REGION_N:CENTRAL REGION, etc.
```





The code chunk below create **function** extract_kml_field to extract values from the HTML description.





```{r}
extract_kml_field <- function(html_text, field_name) {
  # return NA if missing or empty
  if (is.na(html_text) || html_text == "") return(NA_character_)
  
  page <- read_html(html_text)          #parse the HTML string 
  rows <- page %>% html_elements("tr")  #get all table rows <tr>
  
  value <- rows %>%
    keep(~ html_text2(html_element(.x, "th")) == field_name) %>% #keep row where <th> table header text = field_name
    html_element("td") %>%                                       #take its <td> table data
    html_text2()                                                 #extract clean text
  
  if (length(value) == 0) NA_character_ else value        #return NA if no match, otherwise the value
}
```

```{r}
mpsz <- mpsz %>%
  mutate(
     #for each description string, call the function, It returns a length-1 character per row (or NA)
    REGION_N = map_chr(Description, extract_kml_field, "REGION_N"),
    PLN_AREA_N = map_chr(Description, extract_kml_field, "PLN_AREA_N"),
    SUBZONE_N = map_chr(Description, extract_kml_field, "SUBZONE_N"),
    SUBZONE_C = map_chr(Description, extract_kml_field, "SUBZONE_C")
  ) %>%
  select(-Name, -Description) %>% #drop the raw KML attributes
  relocate(geometry, .after = last_col()) #move the geometry column to the end
```





Interestingly, Quarto prints the object using sf’s print method. That shows a summary and then only the **first 10 rows** by default.





```{r}
mpsz
```





#### 2.3.3 importing Attribute Data Into R

we use **read_csv()** to import the csv file as a tibble dataframe and name it popdata.





```{r}
popdata <- read_csv("data/aspatial/respopagesextod2024.csv")
head(popdata, 5)
```





#### **2.3.4 Data Preparation**

**Variables:**

**PA:** Planning area.

**SZ:** Subzone.

**YOUNG**: Ages 0–24 (0–4, 5–9, 10–14, 15–19, 20–24).

**ECONOMY_ACTIVE**: Ages 25–64 (25–29 … 60–64).

**AGED**: Ages 65+.

**TOTAL:** Sum of all age groups.

**DEPENDENCY**: (YOUNG + AGED)/ECONOMY_ACTIVE ×100 as %

**2.3.4.1 Data Wrangling**





```{r}

popdata2024 <- popdata %>%
  #aggregates population counts (Pop) for each combination of planning area (PA), subzone (SZ), and age group (AG).
  group_by(PA, SZ, AG) %>%
  summarise(`POP`= sum(`Pop`)) %>%
  #reshapes the table so each age group (AG) becomes its own column, with population counts as values.
  ungroup()%>%
  pivot_wider(names_from =AG,
              values_from = POP) %>%
# quick preview of structure
  {glimpse(.) ; .} %>%
  #adds new columns by summing selected age-group columns
  mutate(YOUNG = rowSums(.[3:6])
         +rowSums(.[12])) %>%
  mutate(`ECONOMY ACTIVE` = rowSums(.[7:11]) 
         +rowSums(.[13:15])) %>%
  mutate(`AGED` = rowSums(.[16:21])) %>%
  mutate(`TOTAL` = rowSums(.[3:21])) %>%
  mutate(`DEPENDENCY` = (`YOUNG` + `AGED`)
         /`ECONOMY ACTIVE`) %>%
  # quick preview of structure
  {glimpse(.) ; .} %>%
  #keeps only the useful columns.
  select (`PA`, `SZ`,`YOUNG`,
          `ECONOMY ACTIVE`, `AGED`,
          `TOTAL`, `DEPENDENCY`)
```





**2.3.4.2 Joining the attribute data and geospatial data**





```{r}
popdata2024 <- popdata2024 %>%
  #converts PA and SZ names to uppercase so they will match the geospatial dataset’s fields (SUBZONE_N and PLN_AREA_N are uppercase).
  mutate_at(.vars = vars(PA, SZ),
            .funs = list(toupper)) %>%
  filter(`ECONOMY ACTIVE` > 0)
# quick preview of structure
glimpse(popdata2024)
```





The ECONOMY_ACTIVE column has back ticks, which is because of R's display convention.





```{r}
#joins the attribute table (popdata2024) with the polygon map (mpsz) using subzone name as the key: SUBZONE_N from the map, SZ from the population data.
mpsz_pop2024 <- left_join(mpsz, popdata2024,
                          by = c("SUBZONE_N" = "SZ"))
glimpse(mpsz_pop2024)
```

```{r}
#Saves the combined sf object as an .rds file, which can be reloaded later with read_rds()
write_rds(mpsz_pop2024,"data/rds/mpsz_pop2024.rds")
```





### **2.4 Choropleth Mapping Geospatial Data Using *tmap***

Choropleth mapping shows data by colouring areas such as countries, states, or census zones, using shades or patterns to represent values.

#### **2.4.1 Plotting a choropleth map quickly by using *qtm()***

**qtm():** stands for *Quick Thematic Map* to plot quick, simple maps.





```{r}
tmap_mode("plot")         #plot: static; view: interactive
qtm(shp = mpsz_pop2024,
    fill = "DEPENDENCY")   #attribute/column
```





#### **2.4.2 Creating a choropleth map by using *tmap*’s elements**

**tmap elements**: for detailed, highly customisable maps.





```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile",
                n = 5,
                values = "brewer.blues"),
              fill.legend = tm_legend(
                title = "Dependency ratio")) +
  tm_title("Distribution of Dependency Ratio by Planning Subzone") +
  tm_layout(frame = TRUE) +
  tm_borders(fill_alpha = 0.5) +
  tm_compass(type = "8star", size = 2) +
  tm_scalebar() +
  tm_grid(alpha = 0.2) +
  tm_credits("Source: Planning Sub-zone Boundary from Urban Redevelopment Authority (URA)\n and Popluation Data from Department of Statistics DOS",
             position = c("left","bottom"),
             just = c("left","bottom"),
             outside = TRUE)
```





**2.4.2.1 Drawing a base map using tm_shape().**

By default, tmap draws polygons with a dark gray outline (**gray25**) and a light gray fill (**gray85**).





```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons()
```





**2.4.2.2 Drawing a choropleth map using tm_polygons()**

Here is a summary of the key points of tm_polygons() defaults:

**Classification**: uses the “**pretty**” interval method.

**Colour** scheme: defaults to **ColorBrewer’s Blues3** palette.

**Missing values**: shown in **grey**.





```{r}
tm_shape(mpsz_pop2024)+
  tm_polygons(fill = "DEPENDENCY")
```





**2.4.2.3 Drawing a choropleth map using tm_fill() and tm_borders()**





```{r}
tm_shape(mpsz_pop2024) +
  tm_fill("DEPENDENCY")
```

```{r}
tm_shape(mpsz_pop2024) +
  tm_fill("DEPENDENCY") +
  tm_borders()
```





**Borders** in tm_borders(): by default, polygons are outlined in **light gray**.

**fill_alpha**: controls polygon **transparency** (0 = invisible, 1 = fully opaque).

Other key arguments:

**col**: border colour

**lwd**: border *line width* (default = 1, thin line)

**lty**: border *line type* (default = "solid", others like dashed, dotted)





```{r}
tm_shape(mpsz_pop2024) +
  tm_fill("DEPENDENCY") +
  tm_borders(col = "grey60",
             lwd = 0.1,
             lty = "dashed")
```





#### **2.4.3 Data classification methods of tmap**

tmap supports **ten** data classification methods for choropleth mapping: *fixed, sd, equal, pretty (default), quantile, kmeans, hclust, bclust, fisher, and jenks.*

**2.4.3.1 Plotting choropleth maps with built-in classification methods**





```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile",
                n = 5)) +
  tm_borders(fill_alpha = 0.5)
```





Quantile (above) shows differences more clearly, while Equal interval is better for showing absolute value ranges but may hide variation if data are skewed.





```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "equal",
                n = 5)) +
  tm_borders(fill_alpha = 0.5)
```





**DIY 1:** fixed, sd, equal, pretty (default), quantile, kmeans, hclust, bclust, fisher, and jenks.





```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "sd",
                n = 5)) +
    tm_borders(fill_alpha = 0.5)  
               
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "jenks",
                n = 5)) +
    tm_borders(fill_alpha = 0.5)

tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "bclust",
                n = 5)) +
    tm_borders(fill_alpha = 0.5)

```





**DIY 2:**

Using different class numbers changes map readability. Fewer classes (2–3) give a simple overview but hide variation. Moderate classes (5–7) balance detail and clarity. More classes (10–20) seem similar to 5-7 classes overall but too many classes could reduce clarity. **So 5–7 classes are best for clear and insightful choropleth maps.**





```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile",
                n = 2)) +
  tm_borders(fill_alpha = 0.5)

tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile",
                n = 6)) +
  tm_borders(fill_alpha = 0.5)

tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile",
                n = 10)) +
  tm_borders(fill_alpha = 0.5)

tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile",
                n = 20)) +
  tm_borders(fill_alpha = 0.5)

```





**2.4.3.2 Plotting Choropleth map with custom break**





```{r}
summary(mpsz_pop2024$DEPENDENCY)
```

```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                breaks = c(0, 0.60, 0.70, 0.80, 0.90, 1.00))) +
  tm_borders(fill_alpha = 0.5)
```





#### **2.4.4 Colour Scheme**

**2.4.4.1 Using ColourBrewer palette**





```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile",
                n = 5,
                values = "brewer.greens")) +
  tm_borders(fill_alpha = 0.5)
```





Using **"-"** to reverse the colour shading.





```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile",
                n = 5,
                values = "-brewer.greens")) +
  tm_borders(fill_alpha = 0.5)
```





**2.4.4.2 Cartographic Furniture**

The code chunk below uses **tm_compass(), tm_scale_bar(), tm_grid() and tm_credit()** to draw cartographic furniture like compass, scale bar, grid lines.





```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile",
                n = 5)) +
  tm_borders(fill_alpha = 0.5) +
  tm_compass(type = "8star", size = 2) +
  tm_scalebar() +
  tm_grid(lwd = 0.1, alpha = 0.2) +
  tm_credits("Source: data.gov.sg & Singstat",
            position = c("left", "bottom"))
```





#### **2.4.5 Map Layout**

**2.4.5.1 Map Legend**





```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile",
                n = 5),
              fill.legend = tm_legend(
                title = "Dependency ratio")) +
  tm_pos_auto_in() +
  tm_borders(fill_alpha = 0.5) +
  tm_compass(type ="8star", size = 2) +
  tm_scalebar() +
  tm_grid(lwd = 0.1, alpha = 0.2) +
  tm_credits("Source: data.gov.sg & singstat",
             position = c("left","bottom"))
```





**2.4.5.2 Map style**





```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile",
                n = 5,
                values = "-brewer.greens")) + 
  tm_borders(fill_alpha = 0.5) + 
  tmap_style("natural")
```

```{r}
#reset to default style; options: white (default), gray, natural, classic, cobalt, albatross, beaver, and bw (black & white).

tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile",
                n = 5,
                values = "-brewer.greens")) + 
  tm_borders(fill_alpha = 0.5) + 
  tmap_style("white")
```





### **2.5 Drawing Small Multiple (Facet) Choropleth Maps**

#### **2.5.1 By assigning multiple values to at least one of the aesthetic arguments**

*Why my maps are arranged vertically but the ones in example are shown horizontally?*





```{r}
# assigning two variables to the visual variable (fill)
tm_shape(mpsz_pop2024) + 
  tm_polygons(
    fill = c("YOUNG", "AGED"),
    fill.legend = 
      tm_legend(position = tm_pos_in(
        "right", "bottom")),
    fill.scale = tm_scale_intervals(
      style = "equal", 
      n = 5,
      values = "brewer.blues")) +
  tm_borders(fill_alpha = 0.5) +
  tmap_style("natural")
```





#### **2.5.2 By arrange multiples choropleth maps in a grid layout**

In t**map_arrange()**, **asp** controls the panel aspect ratio (height ÷ width): **asp = 1 makes panels square**, asp \> 1 makes them taller than wide, asp \< 1 makes them wider than tall, and asp = 0 allows free stretching. The **ncol** argument sets how many maps are placed per row.





```{r}
youngmap <- tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "YOUNG",
              fill.legend = tm_legend(
                position = tm_pos_in(
                  "right", "bottom"),
                item.height = 0.8),
              fill.scale = tm_scale_intervals(
                style = "quantile",
                values = "brewer.blues")) +
  tm_borders(fill_alpha = 0.5) +
  tm_title("Distribution of young population")

agedmap <- tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "AGED",
              fill.legend = tm_legend(
                position = tm_pos_in(
                  "right", "bottom"),
                item.height = 0.8),
              fill.scale = tm_scale_intervals(
                style = "quantile",
                values = "brewer.blues")) +
  tm_borders(fill_alpha = 0.5) +
  tm_title("Distribution of young population")

tmap_arrange(youngmap, agedmap, asp = 1, ncol = 2)
```





#### **2.5.3 By defining a group-by variable in *tm_facets()***

The code below uses tm_facets() to split the map into facets by region name, arranged in 2 rows × 3 columns; each facet has its own coordinate system (**free.coords**), and subzones not in that facet are dropped (**drop.units**).

In R, **c()** stands for **combine**. It creates a vector by combining multiple values into one object.





```{r}
tm_shape(mpsz_pop2024) +
  tm_fill(fill = "DEPENDENCY",
          fill.scale = tm_scale_intervals(
            style = "quantile",
            values = "brewer.blues")) + 
  tm_facets(by = "REGION_N",
            nrow = 2, 
            ncols = 3,
            free.coords=TRUE, 
            drop.units=TRUE) +
  tm_layout(legend.show = TRUE,
            title.position = c("center", "center"), 
            title.size = 20) +
  tm_borders(fill_alpha = 0.5)
```





### **2.6 Mappping Spatial Object Meeting a Selection Criterion**





```{r}
mpsz_pop2024 %>%
  filter(REGION_N == "CENTRAL REGION") %>%
  tm_shape() +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile",
                values = "brewer.greens"),
              fill.legend = tm_legend()) +
  tm_borders(fill_alpha = 0.5)
```





### **2.7 Complementing Thematic Map with Statistical Chart**

Legend charts are small charts that are added to the map, usually in addition to legends. Arguments that could be assigned to **fill.chart** are *tm_chart_histogram(), tm_chart_bar(), tm_chart_donut(),tm_chart_violin(), tm_chart_box(), tm_chart_none(),tm_chart_heatmap().*





```{r}
mpsz_pop2024 %>%
  filter(REGION_N == "CENTRAL REGION") %>%
  tm_shape() +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile",
                values = "brewer.greens"),
              fill.legend = tm_legend(),
              fill.chart = tm_chart_box()) + #other options 
  tm_borders() +
  tm_layout(asp = 0.8)
```

```{r}
mpsz_selected <- mpsz_pop2024 %>%
  filter(REGION_N == "CENTRAL REGION")

stats <- boxplot.stats(mpsz_selected$DEPENDENCY)

outlier_vals <- stats$out #$out gives the outlier values of DEPENDENCY (those outside 1.5×IQR rule).

outlier_sf <- mpsz_selected[mpsz_selected$DEPENDENCY %in% outlier_vals, ]

tm_shape(mpsz_selected) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile",
                values = "brewer.blues"),
              fill.legend = tm_legend(),
              fill.chart = tm_chart_box()) +
  tm_borders(fill_alpha = 0.5) +
tm_shape(outlier_sf) +
  tm_borders(col ="red", lwd = 2) +
  tm_text("SUBZONE_N", col = "red", size = 0.7) +
  tm_layout(asp = 0.8)
```





### **2.8 Creating Interactive Map**

Interactive maps (**tmap_mode("view")**) let users zoom, pan, and click for details.





```{r}
region_selected <- mpsz_pop2024 %>%
  filter(REGION_N== "CENTRAL REGION")
region_bbox <- st_bbox(region_selected)

stats <- boxplot.stats(region_selected$DEPENDENCY)
outlier_vals <- stats$out
outlier_sf <- region_selected[region_selected$DEPENDENCY %in% outlier_vals, ]

tmap_mode("view")
tm_shape(region_selected,
         bbox = region_bbox) +
  tm_fill("DEPENDENCY",
          id = "SUBZONE_N",
          popup.vars = c(
            "Name" = "SUBZONE_N",
            "Dependnecy" = "DEPENDENCY")) +
  tm_borders() +
  tm_shape(outlier_sf) +
  tm_borders(col = "red", lwd = 2)
```





The code chunk below adds **tmap_mode("plot")** after producing the interactive map to **reset** to static mode for subsequent maps.





```{r}
tmap_mode("plot")
```





THe code chunk blow uses **tm_view(set_zoom_limits = c(12,14))** to control zoom freedom and keep the view focused.





```{r}
region_selected <- mpsz_pop2024 %>%
  filter(REGION_N== "CENTRAL REGION")
region_bbox <- st_bbox(region_selected)

stats <- boxplot.stats(region_selected$DEPENDENCY)
outlier_vals <- stats$out
outlier_sf <- region_selected[region_selected$DEPENDENCY %in% outlier_vals, ]

tmap_mode("view")
tm_shape(region_selected,
         bbox = region_bbox) +
  tm_fill("DEPENDENCY",
          id = "SUBZONE_N",
          popup.vars = c(
            "Name" = "SUBZONE_N",
            "Dependnecy" = "DEPENDENCY")) +
  tm_borders() +
  tm_shape(outlier_sf) +
  tm_borders(col = "red", lwd = 2) +
  tm_view(set_zoom_limits = c(12,14))
```

```{r}
#reset to static maps
tmap_mode("plot")
```





The end.

