---
title: "Hands-on Exercise 02-1: First-order Spatial Point Pattern Analysis"
author: "Yiqiong PAN"
date: "Sep 02, 2025"
date-modified: "last-modified"
execute: 
  eval: true
  echo: true #display the code
  warning: false 
  freeze: true # not render if nothing edited
---

# Overview

**Spatial Point Pattern Analysis** (SPPA) refers to the study of how points are arranged or distributed across a given surface. There points may represent:

-   **Events**, such as crimes, road accidents, or disease occurrences, or

-   **Service and facility locations**, including shops (e.g., cafes, supermarkets) and community facilities like childcare or aged care centres.

**First-order** **Spatial Point Pattern Analysis** (1-st SPPA) examines the intensity or density of points across a study area. It identifies spatial trends in point distribution without considering interaction between points helping to answer questions like:

-   Where are points most concentrated?

-   Is density uniform or variable?

-   How dispersed is the pattern?

> In this exercise, the [**spatsat**](https://cran.r-project.org/web/packages/spatstat/) is utilised to apply two common 1st-SPPA methods to explore:
>
> 1.  Whether childcare centres in Singapore are randomly distributed;
>
> 2.  If not, identifying areas with higher concentrations of centres.

# The Data

The following datasets were downloaded from publicly available websites, and both are available in KML and GeoJSON format.

| Dataset Name | Source | Discrption |
|------------------------|------------------------|------------------------|
| Child Care Services | [data.gov.sg](data.gov.sg) | **Point feature data**: contains the locations and attributes of childcare centres. |
| Master plan 2019 Subzone Boundary (No Sea) | [singstat](https://www.singstat.gov.sg/) | **Polygon feature data**: represents the URA 2019 Master Plan planning subzone boundaries. |

# Installing and Loading the R Packages

In addition to *spatstat*, a total of five R packages will be used in this exercise.

| Package | Discription |
|------------------------------------|:-----------------------------------|
| [sf](https://r-spatial.github.io/sf/) | Simple Features, a new R package which handles importing, managing, and processing vector-based geospatial data. |
| [spatstat](https://spatstat.org/) | Provides useful functions for SPPA, which will be called to conduct both 1st and 2nd SPPA and KDE. |
| [terra](https://rspatial.github.io/terra/index.html) | Modern package for raster/vector spatial data and will be used to convert spastat outputs into terra format. |
| [tmap](https://cran.r-project.org/web/packages/tmap/index.html) | Creates high quality static or interactive choropleth maps via [leaflet](https://leafletjs.com/). |
| [rvest](https://rvest.tidyverse.org/) | Scrapes and extracts data from web pages. |

After installation, we load them into R environment using the code below.

```{r}
pacman:: p_load(sf, terra, spatstat, tmap, rvest, tidyverse)
```

# Importing and Wrangling Geospatial Data Sets

The following code chunk shows the steps to first import the `Master plan 2019 Subzone Boundary (No Sea)` data using st_read, extract the required 4 columns from the `Description` field, filter out the nearby islands, and finally save the file as `mpsz_cl` for further analysis.

```{r}
mpsz_sf <- st_read("data/MasterPlan2019SubzoneBoundaryNoSeaKML.kml") %>%
  st_zm(drop = TRUE, what = "ZM") %>%
  st_transform(crs = 3414)
```

```{r}
extract_kml_field <- function(html_text, field_name) {
  if (is.na(html_text) || html_text == "") return(NA_character_)
  
  page <- read_html(html_text)
  rows <- page %>% html_elements("tr")
  
  value <- rows %>%
    keep(~ html_text2(html_element(.x, "th")) == field_name) %>%
    html_element("td") %>%
    html_text2()
  
  if (length(value) == 0) NA_character_ else value
}
```

```{r}
# map_chr of purr (tidyverse) applies a function to each element of a list/vector and returns a character vector.
mpsz_sf <- mpsz_sf %>%
  mutate(
    REGION_N = map_chr(Description, extract_kml_field, "REGION_N"),
    PLN_AREA_N = map_chr(Description, extract_kml_field, "PLN_AREA_N"),
    SUBZONE_N = map_chr(Description, extract_kml_field, "SUBZONE_N"),
    SUBZONE_C = map_chr(Description, extract_kml_field, "SUBZONE_C")
  ) %>%
  select(-Name, -Description) %>%
  relocate(geometry, .after = last_col())
```

```{r}
mpsz_cl <- mpsz_sf %>%
  filter(SUBZONE_N != "SOUTHERN GROUP",
         PLN_AREA_N != "WESTERN ISLANDS",
         PLN_AREA_N != "NORTH-EASTERN ISLANDS")
```

```{r}
write_rds(mpsz_cl,
          "data/mpsz_cl.rds")
```

The code chuck below imports downloaded `ChildCareServices` data to R as sf data frame as `childcare_sf` by using st_read, coverts 3d to 2d (st_zm) and finally transform the CRS from WGS84 to SVY21.

```{r}
childcare_sf <- st_read("data/ChildCareServices.geojson") %>%
  st_zm(drop = TRUE, what = "ZM") %>% # Drop Z and M to convert from multi-dimensional to 2d (XY)
  st_transform(crs = 3414)
```

## Mapping the Geospatial Data Sets

Using the tmap mapping methods, the code chunk below creates a map combining `childcare_sf` and `mpsz_cl`.

```{r}
tm_shape(mpsz_cl)+
  tm_fill(col = "grey" ) +
  tm_borders(col = "black") +
tm_shape(childcare_sf) +
  tm_dots(col = "black")
```

Alternatively, an interactive thematic map can be plotted using the code below. The interactive map is easy to navigate and query intuitively. It is optional to change the background map layer(choices: ESRI.WorldGrayCanvas(default), OpenStreetMap, ESRI.WorldTopoMap).

```{r}
tmap_mode('view')
tm_shape(childcare_sf) +
  tm_dots() #creates a layer of dots to visualise point data on a map.
```

```{r}
tmap_mode('plot') #switch back static maps
```

::: callout-warning
It is advised to always switch back to plot mode to save connection consumption and limit the number of interactive maps to 10 in one documents when publishing.
:::

# Geospatial Data Wrangling

In this section, the data (sf objects) will be converted to spatstat data structure: **ppp** (for point data) and **owin** for observation window.

## Converting sf Data Frames to PPP

Here we use `as.ppp()` of spatstat package to covert the point data `childcare_sf` to ppp file, confirm the change using `class()` and have a quick overview of the data statistics via `summary()`.

```{r}
childcare_ppp <- as.ppp(childcare_sf)
class(childcare_ppp)
```

```{r}
summary(childcare_ppp)
```

Before moving forwards, let's check if there are any duplicated points.

```{r}
any(duplicated(childcare_ppp))
```

## Creating Owin Object

Similarly, the owin object can be created using the function as.owin() for polygon data. After the conversion, the class() and plot() functions can be used to verify that the object is of the correct class and that the data retains its original shape.

```{r}
sg_owin <- as.owin(mpsz_cl)
class(sg_owin)
plot(sg_owin)
```

## Combining Point Events object and Owin Object

The code chunk below combines ppp and owin into one ppp file which means it updates the window of childcare_ppp to sg_owin and keeps the points that fall inside.

```{r}
childcareSG_PPP = childcare_ppp[sg_owin]
class(childcareSG_PPP)
childcareSG_PPP
```

*why does plotting not work here?*

```{r}
summary(childcareSG_PPP)
plot(childcareSG_PPP)
```

# Clark-Evans Test for Nearest Neighbour Anaylysis (NNA)

Nearest Neighbor Analysis (NNA) is a general spatial analytical approach that examines the distribution of points by calculating the average nearest-neighbour distance to identify whether the pattern is clustered, random, or regular.

The Clark-Evans Test is a specific method within the NNA framework that uses the Clark-Evans aggregation index (R) to evaluate the spatial distribution of points.

> The interpretation rule is:
>
> **ùëÖ\< 1**: clustered pattern
>
> **ùëÖ= 1**: random pattern
>
> **ùëÖ\> 1**: regular pattern

In this study, the function `clarkevans.test()` from the spatstat package will be used. The hypotheses are defined as follows:

Null hypothesis (H0): Childcare services are randomly distributed.

A 95% confidence level will be applied for the test.

## Performing the Clark-Evans Test without CSR (Monte Carlo)

`clarkevans.test()`has two modes without CSR and with CSR. Here we try out the mode without CSR. The alternative hypothesis (H1) here is the childcare services in Singapore are **clustered**.

**Statistical Conclusion** Since the Clark-Evans test shows an aggregation index R 0.535 which is less than 1 and p value is close to zero, we reject the null hypothesis of random pattern and conclude the childcare services in Singapore are clustered at 95% confidence level.

**Business Communication** The statistical results indicate that childcare centres in Singapore are unevenly distributed across the island. Given the critical role of childcare services in supporting social welfare and community stability, it is essential to identify underserved areas and prioritise them in future planning.

```{r}
clarkevans.test(childcareSG_PPP,
                correction = "none",
                clipregion = "sg_owin",
                alternative= c("clustered")
                )
```

## Performing the Clark-Evans Test with CSR (Monte Carlo?)

The code chunk below performs Clark-Evans Test with 99 times simulation.

**Statistical Conclusion** The Clark-Evans test shows an aggregation index R 0.535 and p value of 0.01. As a result we reject the null hypothesis of random pattern (CSR) and conclude the childcare services in Singapore are more clustered at 95% confidence level.

**Business Communication** The statistical results based on 99 Monte Carlo simulations confirm that childcare centres in Singapore are not evenly distributed. It is therefore essential to identify underserved areas and prioritise them in future planning. Policymakers may consider providing incentives to attract service providers to establish new centres in these regions or, in the interim, offering subsidies to local families to ensure a smoother transition and equitable access to childcare services.

```{r}
clarkevans.test(childcareSG_PPP,
                correction ="none",
                clipregion ="sg_owin",
                alternative= "less",
                method = "MonteCarlo",
                nsim = 99)
```

# Kernel Density Estimation Method

Kernel Density Estimation (KDE) creates a continuous surface from point data, allowing us to visualise clusters, hotspots, and spatial variation.It provides an initial understanding of childcare service distribution in Singapore.

## Working with Automatic Bandwidth Selection Method

The `density()` function is used to compute a KDE of the `childcareSG_PPP` point pattern and smooth these point locations into a continuous intensity surface. `sigma` is the bandwidth (smoothing parameter): a smaller sigma produces a spikier output, while a larger sigma smooths the surface. Bandwidth selectors include `bw.diggle`, `bw.CvL`, `bw.scott`, and `bw.ppl`. Enabling edge correction helps avoid border bias. The kernel function defines the shape of the smoothing: "gaussian" is the smoothest, while alternatives such as "epanechnikov", "quartic", or "disc" produce sharper surfaces.

```{r}
kde_SG_diggle <- density (
  childcareSG_PPP,
  sigma = bw.diggle,
  edge = TRUE,
  kernel = "gaussian")
```

The density() function in spatstat returns an `im` object, a pixel image that stores raster data as a grid of values. Each pixel represents intensity at that location, and the result can be visualised using `plot()` and `summary()` for a quick overview.

```{r}
plot(kde_SG_diggle)
summary(kde_SG_diggle)
```

We can also check the bandwidth using `bw.diggle()`.

```{r}
bw <- bw.diggle(childcareSG_PPP)
bw
```

## Rescalling KDE Values

As seen in the summary statistic of `kde_SG_diggle`, the KDE output ranges from 0 to 0.000037 which is hard to connect with real world interpretation. Since this is due to the unit in SVY21 is metre, here we convert the unit from metre to kilometre using `rescale.ppp()`.

```{r}
childcareSG_ppp_km <- rescale.ppp(
  childcareSG_PPP, 1000, "km")
summary(childcareSG_ppp_km)
```

The code chunk below computes KDE in km, summrise and plot KDE. Now the legend confirms the change of unit measurement.The KDE results show that certain areas (in yellow) have an estimated intensity of more than **30** childcare centres per square kilometre.

```{r}
kde_childcareSG_km <- density(childcareSG_ppp_km,
                              sigma = bw.diggle,
                              edge = TRUE,
                              kernel = "gaussian")
summary(kde_childcareSG_km)
plot(kde_childcareSG_km)
```

## Working with Different Automatic Bandwidth Methods

As mentioned before, there are four automatic bandwidth methods. Let's compare and see the difference for one ppp data.

```{r}
bw.CvL(childcareSG_ppp_km)
bw.scott(childcareSG_ppp_km)
bw.ppl(childcareSG_ppp_km)
bw.diggle(childcareSG_ppp_km)
```

Baddeley et al. (2016) suggest using `bw.ppl()` for patterns with many tight clusters, while `bw.diggle()` is better for detecting a single tight cluster in random noise. The following code compares KDE results using both methods.The KDE results from **bw.ppl** on the right show that certain areas (in yellow) have an estimated intensity of more than **25** childcare centres per square kilometre. The PPL bandwidth (0.379) is close to Diggle‚Äôs (0.296) but avoids excessive spikiness, while being much smaller than CvL (4.357), which produces an overly smoothed surface.

```{r}
kde_childcareSG.ppl <- density(childcareSG_ppp_km,
                               sigma = bw.ppl,
                               edge = TRUE,
                               kernel = "gaussian")

summary(kde_childcareSG.ppl)
```

```{r,fig.width=16, fig.width=16}
par(mfrow = c(2,2))#shows two plots side by side (1 row, 2 columns).
plot(kde_childcareSG_km)
title(main = "bw.diggle") #main is the title of the plot, im object

plot(kde_childcareSG.ppl)
title(main = "bw.ppl")

plot(density(childcareSG_ppp_km,
              sigma = bw.scott,
              edge = TRUE,
              kernel = "gaussian"))
title(main = "bw.sscott")

plot(density(childcareSG_ppp_km,
              sigma = bw.CvL,
              edge = TRUE,
              kernel = "gaussian"))
title(main = "bw.CvL")     
```

## Working with Different kernel Methods

Next we compare difference between kernel methods (Gaussian, Epanechnikov, Quartic and Disc) through the charts.

```{r,fig.width=16, fig.width=16}
par(mfrow = c(2,2)) # par= plot appearance settings, mfrow= multi-frame by row e.g. 2 * 2.
plot(density(childcareSG_ppp_km,
             sigma = 0.2959712,
             edge = TRUE,
             kernel = "gaussian"),
             main = "Gaussian")
plot(density(childcareSG_ppp_km,
             sigma = 0.2959712,
             edge = TRUE,
             kernel = "epanechnikov"),
             main = "Epanechnikov")
plot(density(childcareSG_ppp_km,
             sigma = 0.2959712,
             edge = TRUE,
             kernel = "quartic"),
             main = "Quartic")
plot(density(childcareSG_ppp_km,
             sigma = 0.2959712,
             edge = TRUE,
             kernel = "disc"),
             main = "Disc")
```

# Fixed and Adaptive KDE

## Computing KDE by Using Fixed Bandwidth

In the section, we define the bandwidth 600 metres or 0.6 km for the KDE layer.

```{r}
kde_childcare_fb <- density(childcareSG_ppp_km,
                            sigma = 0.6,
                            edge = TRUE,
                            kernel = "gaussian")
plot(kde_childcare_fb)
```


