---
title: "01-1 Geospatial Data Science with R"
author: "Yiqiong PAN"
date: "Aug 28, 2025"
date-modified: "last-modified"
format: 
  html:
    toc: true
    toc-depth: 6
execute:
  echo: true #display the code
  eval: true 
  message: false
  warning: false
  freeze: true # not render if nothing edited
editor: visual
---

**Notes from Week 1**

**Representing Features on a Map**

-   Buildings (HDB Complex)

    Polygon:best for representing the footprint/shape.

    Point (centroid):useful for labeling or when footprint detail is unnecessary.

    Multipoint: ometimes used if a complex has multiple discrete buildings but you do not need exact footprints.

-   Roads: represented as lines. PIE is best represented as a **MultiLineString with breaks** at exits/intersections

-   Drop-off / POIs (e.g., PIE drop-off): often points.

-   Southern Islands: multipolygon, since multiple land masses form one feature.

**Geographic vs Projected Coordinate Systems**

Geographic Coordinate System (GCS)

-   Uses longitude/latitude (WGS84, EPSG:4326).

-   Units: degrees (decimal or DMS).

-   Good for locating positions.

-   Not accurate for distance/area because the Earth is an ellipsoid.

-   Example: 1° longitude at equator ≠ 1° longitude at 45°N/S or the pole (varies by location).

Projected Coordinate System (PCS)

-   “Flattens” Earth by projecting onto a plane.

-   Units: metres or feet.

-   Necessary for distance/area analytics.

-   Many types of projections (equal-area, conformal, equidistant, etc.), each preserving different properties.

-   Always transform data into PCS before spatial analysis.

-   SVY21 (EPSG:3414) is Singapore’s gazetted PCS.

**File Formats**

SHP (ESRI Shapefile)

-   Well-structured, comes with multiple associated files (.shp, .shx, .dbf, etc.).

-   Contains both geometry and attribute tables.

-   Preferred for robust data exchange.

KML (Keyhole Markup Language)

-   XML-based, can be opened in Notepad.

-   Lightweight but less structured.

-   Often used for sharing data via Google Earth/Maps.

In R (sf package)

-   class(mpsz): returns sf, data.frame.

-   Means it behaves like both a spatial object and a data frame.

**Practical Notes**

-   Different map versions may have different boundaries. Although R could sync to the versions by using precision classification, always use the latest version.

-   Always reproject to PCS before measuring area/distance. (st_transform)

-   Use SHP whenever possible for structured workflows and compatibility.

## 1 Getting Started: Installing and Launching R Packages

The following code chunk uses the **p_load()** function from the pacman package to check whether the **sf** and **tidyverse** packages are installed. If they are, it loads them into the R session; if not, we could install them first via function **install.packages()** and then load them into R by using p_load().

```{r}
pacman::p_load(sf,tidyverse)
```

## 2 Importing the Data

The geospatial datasets include **shapefiles** and **KML** file. (The reason of selecting file format). The geospatial data consist of the **Master Plan 2014 Subzone Boundary (Web)**, **Pre-Schools Location** from data.gov.sg, and **Cycling Path** from LTA DataMall. The aspatial dataset is the **Singapore Airbnb listings** from Inside Airbnb.

R itself is **case-sensitive**, especially for object and function names. Whether file paths are case-sensitive depends on the operating system, e.g. On Windows: it is **not** **case-sensitive**.

### 2.1 Importing Polygon Data Frame

The code below uses the **st_read()** function from the sf package to load the Master Plan 2014 Subzone Boundary (Web) shapefile as a **polygon** data frame. For shapefiles, the .shp extension does not need to be specified in the code. Both absolute and relative paths can be used, but a relative path is applied here to keep the code cleaner and shorter.

```{r}
mpsz = st_read(dsn = "data/geospatial",
               layer = "mp14_SUBZONE_WEB_PL")
```

### 2.2 Importing Polyline Data Frame

Similarly, the code below uses st_read() to import the Cycling Path shapefile as a **polyline** data frame.

```{r}
cyclingpath = st_read(dsn = "data/geospatial",
                      layer = "CyclingPathGazette")
```

### 2.3 Importing Point Data Frame

The code below uses st_read() to import the Pre-Schools Location in KML format as **point** feature data frame into R. When importing a KML file, the .kml extension must be **included**.

svy21 vs wgs84?

```{r}
preschool = st_read("data/geospatial/PreSchoolsLocation.kml")

```

Alternatively, we can combine `st_read` with `st_transform` together via **nested** functions `%>%`.

```{r}
preschool = st_read("data/geospatial/PreSchoolsLocation.kml") %>%
  st_transform(crs = 3414)

```

## 3. Checking the Content of a Simple Feature Data Frame

Both **two** code chunks display the basic information about the dataset. However, it is more common to use the second approach.

```{r}
mpsz$geom
st_geometry(mpsz)
```

Although it is mentioned as one of the ways to retrieve the first 5 records like the two code chunks above, but here we see seems to be ID column?

```{r}
mpsz[[1]]
```

Furthermore, the code below uses **glimpse()** of dplyr to display **more** detailed attribute information in the data frame.

```{r}
glimpse(mpsz)
```

Lastly, the code below uses the **head()** function from base R (similar to Python, where the argument n can be set manually) to display the first few rows of the data frame for a quick overview.

```{r}
head(mpsz, n=5)
```

## 4. Plotting the Geo spatial Data

Visualising an sf data frame is straightforward: using the **plot()** of Base R function automatically generates **small** **coloured** maps of the geometries by each attribute (field), while excluding non-informative columns such as the OBJECTID.

```{r}
plot(mpsz)
```

Meanwhile, the code chunk below can be used to display the **silhouette** of the map:

```{r}
plot(st_geometry(mpsz))
```

We can also focus on **a specific attribute** by using the code chunk below:

```{r}
plot(mpsz["PLN_AREA_N"])
```

To get a polished view of the data, we can use the **tmap** package, but it takes longer processing time:

```{r}
#library(tmap)
#tm_shape(mpsz) +
  #tm_fill("PLN_AREA_N")+
  #tm_borders()

## comment out to save time
```

Below we quickly plot the preschool and cyclingpath.

```{r}
plot(st_geometry(preschool))
plot(st_geometry(cyclingpath))
```

Below we can plot the **cyclingpath** layer on the top of the **mpsz** layer by using **add argument**.

```{r}
plot(st_geometry(mpsz))
plot(st_geometry(cyclingpath),
     add = TRUE, col = "Blue")
```

When trying the code with preschool, the **preschool** points does **not** appear on the **subzone** map because the two layers use **different CRSs** (mpsz in SVY21 and preschool in WGS84), transformation of preschool into the same CRS as mpsz is required before plotting the aligned map.

```{r}
plot(st_geometry(mpsz))
plot(st_geometry(preschool),
     add = TRUE)
```

## 5. Projection Transformation

```{r}
st_crs(mpsz)
st_crs(preschool)
st_crs(cyclingpath)
```

The above funtion **st_crs()** reveals that the layers of mpsz and cyclingpath are indeed in SVY21, but they are missing the correct EPSG code (3414). **Assigning** EPSG 3414 by using **st_set_crs() of sf** packages ensures the CRS is properly identified, as below:

```{r}
mpsz <- st_set_crs(mpsz,3414)
st_crs(mpsz)
```

On the other hand, the code below using **st_transform()** **reprojects** the preschool data from the WGS84 to **SVY21**.

```{r}
preschool <- st_transform(preschool,
                          crs = 3414)
```

By display the preview of preschool sf data, we can confirm its CRS is **SVY21** now.

```{r}
st_geometry(preschool)
```

Here we could **align** both data together by setting **add** argument **TRUE**.

```{r}
plot(st_geometry(mpsz))
plot(st_geometry(preschool), add = TRUE)
```

## 6. Importing and Converting an Aspatial Data

### 6.1 Importing CSV

The chunk below first uses **read_csv()** from readr to import listing.csv into R as a tibble data frame, and then applies **list() from base R** to preview the first 10 records, similar to **glimpse() of dplyr.**

```{r}
listings <- read_csv("data/aspatial/listings.csv")
list(listings)
```

### 6.2 Preview of the Data

The code chunk below uses **st_as_sf()** **of sf package** to convert the listings data frame into a simple feature data frame. Specifically the coordinates are first defined in **WGS84 (EPSG:4326, longitude/latitude in degrees**) and then **reprojected** into Singapore’s **SVY21 system** (**EPSG:3414, X/Y in metres**).

```{r}
listings_sf <- st_as_sf(listings,
                        coords = c("longitude", "latitude"),
                        crs = 4326) %>% #used to nest st_transform() 
  st_transform(crs = 3414)
```

```{r}
glimpse(listings_sf)
```

**DIY:** the code chuck below plots listings_sf onto mpsz layer. The map looks better when ploting mpsz first and then listings_sf, because the polygons give context (the “base map”), and the points can be layered on top without being hidden. Thus better order is **polygons first, points later**.

```{r}
plot(st_geometry(mpsz))
plot(st_geometry(listings_sf), add = TRUE)
```

```{r}
#plot(st_geometry(listings_sf))
#plot(st_geometry(mpsz), add = TRUE)
```

## 7. Geoprocessing with SF Package

### 7.1 Use case 1: Land Acquisition Analysis

Task: compute the total land area to reserve for a 5-m corridor/shoulder on both sides of the cycling paths.

***\<- assignment** (always use this for storing values/importing data).*

***= function arguments** (inside function calls).*

**Solution:**

**Step 1:** **st_buffer()** of sf package: 5-metre buffers of reserved land on both sides of existing cycling path.

```{r}
# quick review of the geometry type
st_geometry_type(cyclingpath, by_geometry = FALSE)
```

```{r}
# quick overview of the cycling path data
glimpse(cyclingpath)
```

```{r}
buffer_cycling <- st_buffer(
  cyclingpath, dist=5, nQuadSegs = 30)

#st_buffer()builds polygons at a fixed offset from a geometry.
#cyclingpath is input, multilinestrings layer
#dist=5, buffer distance in the layer's units. 
#Here CRS is SVY221 in metre, thus no transformation is required.
#nQuadSegs = 30, higher the value, smoother the curve in the buffer around corners or ends.
#stands for “number of line segments to use to approximate a quarter circle".
```

**Step 2:** use **st_area()** to calculate each area of the buffers

```{r}
buffer_cycling$AREA <- st_area(buffer_cycling)
#st_area() returns area of each feature in the geometry column
# units vector (m^2)
#buffer_cycling$AREA adds a new attribute column AREA

```

Alternatively, code uses **tidyverse**

```{r}
buffer_cycling <- buffer_cycling %>%
  mutate(AREA = st_area(geometry))
# mutate() of dplyr, just like the $AREA, creates a new column AREA
#geometry is the sf geometry column; st_area(geometry) computes area for each row.
```

**Step 3:** **sum()** of Base R to add up all AREA values.

***What if the areas are overlapped?***

```{r}
sum(buffer_cycling$AREA)
```

**Step 4:** **plotting** the buffer by a selected planning subzone: **Tampines West**

a.  **filter()** of dplyr package to select the subzone

```{r}
#quick overview of the mpsz
glimpse(mpsz)

mpsz_selected <- mpsz %>%
  filter(SUBZONE_N == "TAMPINES WEST")
#quick overview of the newly selected subzone
st_geometry(mpsz_selected)
#creating a plot for the subzone in general
plot(st_geometry(mpsz_selected))
```

b.  **st_intersection()** of sf package to clip clycing buffers within the subzone. Both layers are in the SVY21. However, since EPSG code is missing in buffer_cycling, we need to **assign** the code 3414 to it before performing intersection.

```{r}
# checking features of the two layers
st_crs(buffer_cycling)$epsg
st_crs(buffer_cycling)$Name
st_crs(mpsz_selected)$epsg
st_crs(buffer_cycling)$Name

# EPSG assignment, or use 3414 as second parameter
buffer_cycling <- st_set_crs(buffer_cycling, st_crs(mpsz_selected))
```

```{r}
buffer_cycling_selected <- st_intersection(
  buffer_cycling, mpsz_selected)
#st_intersection(x, y) returns a new sf object = overlapping parts of x and y
```

c.  **plot()** to create the plot

```{r}
plot(st_geometry(buffer_cycling_selected))
```

**DONE!**

### 7.2 Use Case 2: To determine the number of pre-schools by planning subzone

**Solution**:

**Step 1:** Use **st_intersects()** from the sf package to identify pre-schools located inside each subzone. Then, use the length() function from base R to calculate the number of pre-school points within each subzone. The function st_intersects() returns a **list** of intersections. While **length(**) returns only the total number of subzones, the **lengths()** function works on a list and returns a vector with the length of each element.

```{r}
#perform an overview of both data frames first
glimpse(preschool)
glimpse(mpsz)

#show the outputs individually
st_intersects(mpsz, preschool)
length(st_intersects(mpsz, preschool))
lengths(st_intersects(mpsz, preschool))

#combine the two steps into one-line code
mpsz$`PreSch Count` <- lengths(st_intersects(mpsz, preschool))

#alternatively, using tidyverse way
mpsz <- mpsz %>%
  mutate(`PreSch Count`= lengths(st_intersects(mpsz,preschool)))
```

Note: **st_intersects()** is a **spatial** **predicate** that quickly checks **relationships** between features and returns indices (or a list) showing which features intersect, without creating new geometries. In contrast, **st_intersection()** performs a **full geometric overlay**, generating new sf features that represent the actual overlapping geometries and carrying attributes from both input layers, which is more computationally intensive.

```{r}
# statistical summary for the new column
summary(mpsz$`PreSch Count`)
#top_n() of dplyr package to see the sub zone with the most number of pre-school
top_n(mpsz, 1, `PreSch Count`)
```

**Step 2:** The code chunk below uses **st_area()** from the sf package to calculate the area of each subzone, returning values in square metres because the CRS (SVY21) is in metres. Note that the **SHAPE_Area** field shown in the glimpse(mpsz) output is a precomputed attribute from the original dataset and may not be accurate for current analysis; we rely on st_area() instead.

```{r}
mpsz$AREA <- mpsz %>%
  st_area()

summary(mpsz$AREA)
```

The code chunk below computes preschool density **per km2** ( 1km2 = 1,000,000m2). We convert to per km2 to make the numbers **comparable** and readable.

```{r}
mpsz <- mpsz %>%
  mutate(`PreSch Density` = `PreSch Count`/AREA * 1000000)

#quick overview of the stats for the new column
summary(mpsz$`PreSch Density`)
```

**Step 3: EDA using ggplot2**

a.  Use **hist() of R Graphics** to plot a histogram of the distribution of PreSch Density.

```{r}
hist(mpsz$`PreSch Density`)
```

b.  use **ggplot2** functions to provide informative visualisation.

b1. create a **histogram**

```{r}
#initiates the ggplot using mpsz data fram, set x-axis
ggplot(data=mpsz,
       aes(x = as.numeric(`PreSch Density`))) +
  #adds a histogram layer, with bin numbers, colour and fill colour
  geom_histogram(bins = 20,
                 color = "black",
                 fill = "lightblue") + 
  #adds labels such as title, subtitle, and for x, y axis
  labs(title = "Are pre-school evenly distrubted in Singapore?",
      subtitle = "There are many planning subzones with a single pre-school, on the other hand,\nthere are seven planning subzones with at least 30 or more pre-schools.",
      x = "Pre-school density (per km sq)",
      y = "Frequency")
```

b2. create a **scatterplot** for PreSch Density and PreSch Count.

```{r}

#starts a ggplot with mpsz, and maps x to PreSch Density and y to PreSch Count.
#Uses as.numeric() to drop units from PreSch Density and coerce it to plain numbers
ggplot(data=mpsz,
       aes(y = `PreSch Count`,
           x = as.numeric(`PreSch Density`))) +
  #adds points and colours
  geom_point(shape =21,
             color ="black",
             fill = "lightblue") +
  #sets the range of data from 0 to 40.
  xlim(0,40) +
  ylim(0,40) + 
  #adds labels
  labs(title ="",
       x = "Pre-school density (per km sq)",
       y = "Pre-school count")
```

## 8 Reference

Kam, T. S. Thematic Mapping and GeoVisualisation with R. R for Geospatial Data Science and Analytics. https://r4gdsa.netlify.app/chap01.html
