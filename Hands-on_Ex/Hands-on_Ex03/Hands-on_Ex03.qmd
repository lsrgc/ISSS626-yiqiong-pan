---
title: "03: Spatio-Temporal Point Patterns Analysis"
author: "Yiqiong PAN"
date: "Sep 08, 2025"
date-modified: "last-modified"
execute:
  echo: true #display the code
  eval: true #run the code
  message: false
  warning: false
  freeze: true # not render if nothing edited
editor: visual
format: 
  html:
    number-sections: true
    number-depth: 4
---

## Overview

A **spatio-temporal point process** is a random set of points, each showing when and where an event happens. Examples include disease cases, animal sightings, or natural disasters such as fires and earthquakes.

As more data is collected with both time and location, analysing spatio-temporal patterns has become more important. In recent years, several R packages have been developed for this purpose.

This exercise demonstrates how to apply the process through a case study of **forest fires** in Kepulauan Bangka Belitung, Indonesia, from 1 January to 31 December 2023. Kepulauan Bangka Belitung is an Indonesian province of two main islands, Bangka and Belitung, plus smaller islets, known for tin mining, pepper cultivation, tropical beaches, and diverse cultural heritage.

## Learning Outcome

The key questions we aim to address are:

**1. Are forest fire locations in Kepulauan Bangka Belitung independent in space and time?**

**2. If not, in which areas and during which periods do the forest fires tend to cluster?**

## The Data

For this exercise, the two datasets used are as follows:

1.  forestfires (CSV) contains forest fire locations detected by the Moderate Resolution Imaging Spectroradiometer (MODIS) sensor, obtained from the [Fire Information for Resource Management System](https://firms.modaps.eosdis.nasa.gov/download/). Only records within Kepulauan Bangka Belitung are used.

2.  [Kepulauan_Bangka_Belitung](https://id.wikipedia.org/wiki/Kepulauan_Bangka_Belitung) (Shapefile) contains sub-district ([kelurahan](https://en.wikipedia.org/wiki/Villages_of_Indonesia)) boundaries of Kepulauan Bangka Belitung, extracted from the national dataset available on the [Indonesia Geospatial Portal](https://www.indonesia-geospasial.com/2023/05/download-shapefile-batas-administrasi.html). The region's dry season is May-October and rainy season is October-April.

## Installing and Loading the R Packages

A total of **six** R packages will be used in this exercise.

| Package | Description |
|------------------------------------|------------------------------------|
| [sf](https://r-spatial.github.io/sf/) | Simple Features, a new R package which handles importing, managing, and processing vector-based geospatial data. |
| [raster](https://rspatial.org/raster/) | Tools for reading, writing, and analyzing raster (gridded) spatial data in R |
| [spatstat](https://spatstat.org/) | Provides useful functions for SPPA, including kcross, Lcross etc. |
| [sparr](https://tilmandavies.github.io/sparr/index.html) | Functions for fixed/adaptive kernel density estimation and relative risk mapping via density ratios; also supports fixed-bandwidth space-time density and risk estimation with inference. |
| [tmap](https://r-tmap.github.io/tmap/) | Creates cartographic quality static or interactive choropleth maps. |
| [tidyverse](https://www.tidyverse.org/) | A collection of R packages for data import, cleaning, transformation, and visualization (e.g., readr, dplyr, tidyr, ggplot2). |

: {tbl-colwidths="\[15,85\]"}


After installation via `install.packages()`, we load them into R environment using the code below.

```{r}
pacman:: p_load(sf, raster, spatstat, sparr, tmap, tidyverse)
```

## Importing and Preparing Study Area

::: panel-tabset
### Importing Study Area

First the code chunk below imports study area into R environment.

```{r}
kbb <- st_read(dsn = "data/rawdata",
               layer = "Kepulauan_Bangka_Belitung")
```

```{r}
tm_shape(kbb) +
  tm_borders()

```

After checking the summary and plot, we merge all sub-districts into a single boundary and remove unnecessary Z coordinates. The dataset’s CRS is WGS 84 with units in degrees, which is not suitable for spatial analysis. Therefore, it is transformed into a projected CRS in metres, specifically EPSG:32748 (UTM Zone 48S, WGS 84), which is appropriate for Indonesia.

The R console message indicates that the Z/M coordinates were already dropped when applying st_union(). The st_zm() step is retained here for clarity and consistency.

```{r}
kbb_sf <- kbb %>%
  st_union() %>%  
  st_zm(drop = TRUE, what = "ZM") %>%
  st_transform(crs = 32748)

kbb_sf

class(kbb_sf)

st_bbox(kbb_sf) #the bounding box confirms the location

# par(mfrow=c(1,2)) # base R plotting
kbb_sf_plot1 <- tm_shape(kbb_sf) +
  tm_borders() +
  tm_title("Kepulauan Bangka Belitung 1")

kbb_sf_plot2 <- tm_shape(kbb_sf) +
  tm_polygons() +
  tm_title("Kepulauan Bangka Belitung 2")

tmap_arrange(kbb_sf_plot1, kbb_sf_plot2, asp = 1, ncol = 2)
```

### Converting to `owin` Object

We convert `kbb_sf`, an `sfc_POLYGON` boundary, to an `owin` object to represent the polygonal study area.

`owin` objects are required for spatial point pattern analysis (SPPA) with the `spatstat` package and can be visualised using base R plotting functions. For mapping with `tmap`, however, the boundary should remain as an `sf` object.

```{r}
kbb_owin <- as.owin(kbb_sf)

class(kbb_owin)

summary(kbb_owin)

plot(kbb_owin, main = "Kepulauan Bangka Belitung — study window (owin)")
```
:::

## Importing and Peparing Forest Fire Data

We first import `forestfires.csv` into R with `read_csv()`, which creates a regular `tibble` (non-spatial, no CRS). Next, we convert the longitude/latitude columns into an `sf` object by creating a geometry column of type `sfc_POINT` and assigning `EPSG:4326` (WGS 84). Finally, we reproject to a projected CRS in metres, `EPSG:32748` (UTM Zone 48S, WGS 84) for spatial analysis.

```{r}
fire_tbl <- read_csv("data/rawdata/forestfires.csv")
st_crs(fire_tbl)

fire_sf <- fire_tbl %>%
  st_as_sf(coords = c("longitude", "latitude"),
           crs = 4326) %>%
  st_transform(crs = 32748)

st_crs(fire_sf)

str(fire_sf)
```

The code below converts the `acq_date` column from `Date` format into a `numeric` variable. This step is needed because a `ppp` object in `spatstat` only accepts numeric or character variables as marks, not Date objects. Therefore, functions from lubridate are used to create time-based variables and a 12-level ordered factor (Month_fac) for grouping and plotting.

```{r}
fire_sf <- fire_sf %>%
  mutate (DayofYear = yday(acq_date)) %>%
  mutate(Month_num = month(acq_date)) %>%
  mutate(Month_fac = month(acq_date,
                           label = TRUE,
                           abbr = FALSE))
str(fire_sf)
```

## Visualsing the Fire Points

::: panel-tabset
### Overrall Plot

The code chunk below overlays the polygonal study area `kbb_sf` with the forest file points `fire_sf` using `tmap` package.

```{r}
tm_shape(kbb_sf) +
  tm_polygons() +
tm_shape(fire_sf) +
  tm_dots()
```

### Visuaising by Month

The code chunk below produces a grid of maps, with one map for each month of 2023, to visualise the spatial distribution of forest fires. Each facet uses the same geographic frame, so that it is easy to obverse how fire patterns vary over time and space.

```{r}
#| fig-width: 10
#| fig-height: 8
tm_shape(kbb_sf) +
  tm_polygons() +
tm_shape(fire_sf) +
  tm_dots(size = 0.1) +
tm_facets(by = "Month_fac", #split the map into multiple panels by month factors
          free.coords = FALSE, # all panels share the same coordinate system / map extent.
          drop.units = TRUE)  # drop if some months have no data,
```
:::

## Computing STKDE by Month

In this section, we use `spattemp.density()` to build spatio-temporal `ppp` (with x, y, time) from the `fire_sf` to show when and where forest fires are more likely.

-   `pp`: spatio-temporal point pattern.

-   `h`: spatial bandwidth (how smooth in space).

-   `tt`: temporal bandwidth (how smooth in time).

-   `tlim`: time range to consider.

-   `sedge` / `tedge`: edge corrections for space / time.

-   `sres` / `tres`: resolution of spatial grid / temporal bins.

::: panel-tabset
### A Extracting `Month_num` field

Since `as.ppp()` from spatstat only needs a mark field (e.g numeric field Month_num) and the geometry, this step ensures the data frame is reduced to just what is necessary.

As mentioned above, in `spatstat`, the marks of a `ppp` object could be:

-   numeric mark,quantitative values, which is used for intensity or regression analysis
-   character marks, converted to `factor`, which are then used for for categorical analysis

```{r}
fire_month <- fire_sf %>%
  select(Month_num)

str(fire_month)
plot(fire_month)
```

### B Creating `ppp`

The code chunk below converts sf data frame to `ppp` object.

```{r}
fire_month_ppp <- as.ppp(fire_month)
fire_month_ppp
```

The code chunk below check the summary statistics including object class.

```{r}
summary(fire_month_ppp)
```

The code chunk below performs a quick sanity check to ensure there are no duplicate points, which could avoid biased results or errors.

```{r}
any(duplicated(fire_month_ppp))
```

The code chunk below draws the points for a quick look.

```{r}
plot(fire_month_ppp)
```

### C Adding `owin` Object

`ppp[owin]` in `spatstat` clips the point pattern to a given window. That means only points of e.g. `fire_month_ppp` that fall in the study area `kbb_owin` are kept and outputs a new `ppp` object.

```{r}
fire_month_owin <- fire_month_ppp[kbb_owin]
summary(fire_month_owin)
plot(fire_month_owin)
```

### D computing Spatio-temporal KDE

The code chunk below calculate the STKDE using `spattemp.density()`.

```{r}
st_kde <- spattemp.density(fire_month_owin)

summary(st_kde)
class(st_kde)
```

### E Ploting the STKDE Ojbect

The class of `st_kde` is `stden` which stores a stack of KDE surfaces, one for each time slice. Using `plot(st_kde)` alone, plots 12 monthly KDE. The code chunk below first creates a list for then plots 6 KDE maps between July 23 and December 23 in a 2 \* 3 grid.

```{r, fig.width= 12, fig.height= 8}
tims <- c(7:12)
par(mfcol = c(2,3))
for (i in tims){
  plot(st_kde, i, override.par= FALSE,
       fix.range= TRUE,
       main = paste("KDE at month", i))
}
```

Here we quickly plot the monthly KDE.

```{r, fig.width=12, fig.height=16}
par(mfrow = c(4,3))
plot(st_kde, override.par = FALSE)
```
:::

## Computing STKDE by Day of Year

::: panel-tabset
After conducting the STKDE by month, we proceed to perform the STKDE by day.

### A Creating `ppp` Object

Similar to the steps for computing STKDE by month, the code chunk below selects numeric mark `DayofYear` and coverts the `sf` object to a `ppp` object using the piper operator.

```{r}
fire_yday_ppp <- fire_sf %>%
  select(DayofYear) %>%
  as.ppp()

summary(fire_yday_ppp)
plot(fire_yday_ppp)
```

### B Adding `owin` Ojbect

The code chunk below restricts the point events to observation window, runs a few sanity checks, such as `summary()` and `duplicated()`, and plotz the new `ppp` object for a quick review.

```{r}
fire_yday_owin <- fire_yday_ppp[kbb_owin]
summary(fire_yday_owin)

any(duplicated(fire_yday_owin))
plot(fire_yday_owin)

```

### C Computing STKDE

The code chunk below perform the STKDE using `spattemp.density`.

```{r}
kde_day <- spattemp.density(
  fire_yday_owin)

summary(kde_day)

length(kde_day $tgrid) #check the number of temporal slices
```

### D Visualising STKDE in gif

If we plot `kde_day` directly it will produce 343 KDE maps ( one per day), which is too many to view at once.

```{r}
#| eval: false
plot(kde_day)
```

Here we install the `magick` package and animate the `kde_day` file.

```{r}
#| eval: false

pacman::p_load(magick)

# pick all days, or thin with step=7 for weekly
sel <- seq_along(kde_day$tgrid)   # all 343 days
# sel <- seq(1, length(kde_day$tgrid), by = 7)  # weekly thinning

frames <- lapply(sel, function(i) {
  tsel <- kde_day$tgrid[i]
  img  <- image_graph(width = 800, height = 700, res = 96) # open a plot device

  plot(kde_day, tselect = tsel, override.par = TRUE, fix.range = TRUE,
       main = paste("STKDE – Day", tsel))

  dev.off()
  img
})

# combine frames into gif
anim <- image_animate(image_join(frames), delay = 20, loop = 0)


# save to file
image_write(anim, "stkde_day.gif")
```

Please see the comparison in summary.
:::

## Computing STKE by Day of Year: Improved Method

In this section, we use `BOOT.spattemp()` from `sparr` package to select optimal bandwidths for spatio-temporal kernel density estimation. The function use bootstrap estimation of Mean Integrated Squared Error (MISE) to product an isotropic scalar spatial bandwidth (h) and a scalar temporal bandwidth (lambda).

::: panel-tabset
### A Computing STKDE

When using plug-in rule in `spattemp.density()`, the spatio-temporal bandwidths are 15km and 6.3 days.

The code chunk below applies `boot.spattemp()` generated optimal bandwidths 9km and 19 day to STKDE computation.

We shall get a clear view of fire seasonality and hotspots than the default bandwidths.

```{r}
set.seed(1234)
BOOT.spattemp(fire_yday_owin)
```

```{r}
kde_yday_boot <- spattemp.density(fire_yday_owin,
                                  h = 9000,
                                  lambda = 19)
summary(kde_yday_boot)
```

### B Plotting STKDE in `gif` Format

Here we create animated STKDE using `magick` package.

```{r}
#| eval: false
plot(kde_yday_boot)
```

```{r}
#| eval: false
# pick all days, or thin with step=7 for weekly
sel <- seq_along(kde_yday_boot$tgrid)   # all 343 days
# sel <- seq(1, length(kde_day$tgrid), by = 7)  # weekly thinning

frames <- lapply(sel, function(i) {
  tsel <- kde_yday_boot$tgrid[i]
  img  <- image_graph(width = 800, height = 700, res = 96) # open a plot device

  plot(kde_yday_boot, tselect = tsel, override.par = TRUE, fix.range = TRUE,
       main = paste("STKDE – Day", tsel))

  dev.off()
  img
})

# combine frames into gif
anim_bt <- image_animate(image_join(frames), delay =  20, loop = 0)

# save to file
image_write(anim, "stkde_day_bt.gif")
```

Please see the comparison in summary.
:::

## Summary

Here we provide some preliminary answers to the two questions introduced at the start of this exercise.

**1. Are fires independent in space and time?**

- No. The daily marks show spatial clustering and temporal seasonality, concentrated around Day 200–320.

**2. Where and when do they cluster?**

- When: During the late dry season **Aug–Oct**, peaking around mid-Sep.

- Where: Activity begins in the **north-west**, intensifies in the **south**, and persists into the **south-east**.

The animated maps below compare STKDE using default bandwidths (left) versus bandwidths selected via bootstrap resampling (right).


```{r}
#| echo: false 
#| fig-subcap: ["STKDE Default","STKDE BOOT"] 
#| layout-ncol: 2 
#| fig-align: center 
knitr::include_graphics(c("fig/stkde_day.gif","fig/stkde_day_bt.gif"))
```

## Reference

Kam, T. S. 6 Spatio-Temporal Point Patterns Analysis. R for Geospatial Data Science and Analytics. https://r4gdsa.netlify.app/chap06
